
Core moules ( includes those not requiriing require keword, Global modules)
NPM (Third party modules)
Custom modules

NPM means you can download modules, you can upload modules and also NPM is also a website. When NodeJS is insalled, NPM is also installed.

Most calls are async in nodejs.
Ways of running nodejs
	(a) node A.js  --- > Package.json is not used
	(b) npm run A.js
	(c) nodemon A.js
Node JS core APIs
=======================
https://nodejs.org/dist/latest-v6.x/docs/api/console.html
Note:-- The above is for 6.X series

Node JS third party APIs
=======================
You can search for the package in https://www.npmjs.com/. Search for that in the textbox 'find packages'.
Once you install it, go to the node_modules/<module_name>/README.md file. 
That file api-doc/documentation API links
TODO:-- May be there is a single site where all the 3rd party module APIs are hosted 



GIT (1st time)
========================
git init
git add -A
git commit -am "comment"  // This commits all added and modified files
git config --global user.name "sujithbabu1971" // May be there is a better way to force username
git config --global user.email "sujithkp@yahoo.com" // May be there is a better way to force username
git remote add ExpressJSSamples https://github.com/sujithbabu1971/ExpressJSSamples.git
git push -u  ExpressJSSamples // -u sets the files for pull also. This is important

GIT . Committing a modified file after the 1st time.
========================
git add filename
git commit -m "message" filename
git push 
Note:-- Only adding the file and committing worked for me. May be, there is a better way such as just commit. (Note:-- Later found that if we use -u in git push the 1st time, this step is not needed).



Install express
express-handlebars
express-session
body-parser


With -g (global installation), the --save option that saves into the package.json file does not seem to be working


For express-generator
=====================
First install express-generator globally. We do not need this as a dependancy to the project for obvious reasons.
Then "express myapp". This will create myapp with all the required directory structire. jade is the default template
"express --ejs myapp"  --> The template engine become ejs
"express --hbs myapp"  --> The template engine become handlebars
Fiddle around with these options to understand all that are available. 
Then cd to myapp directory
npm install ---> this will install all dependancies
npm start --> default start command in package.json. This has the start scripts in the ./bin/www folder that was created by express command.

EJS ===> embedded java script templates

YSLOW
=====================

JADE template
==============
No need to close html tags
Use either whitesapce or tab for indentation (Cant mix)
Even if you do not use it, div tag is assumed as the 1st element.
# is for id attribute and . is for class attribute.
Use html2jade for html to jade code conversion. Not all may be converted well. For an example, take care of the varaibles after the conversion.
To include text, just input it after the the tag. Eg: h1 I am good ===>  <h1> I am good</h1>
<input type+"text" placeholder="Username"/> in html ===> input(type="text",placeholder=="UserName")
To access a varaiblename value use =
eg:-- title=name . In this html <title> gets filled with the value from the name varaible.
to inject java scrript use -. (In ejs it was <% %> like in JSP)

When userName is a variable
the following would not work
p.text-center Hello =userName
instead use 
p.text-center Hello 
              =userName
Global scope tip in java script
==============
If you use 
i=10; inside a function, then i is a global varaibale and not limited to that function. Avoid this to ensure the variables are not conflicting.
So use 
var i=10;
Or use let i= 10; // let has access within the for loop/function etc.


Debugging node js applications
===============================
Install nodeclipse. This installation is one where you open an eclipse empty workspace and then drag and drop an image.  Refer http://marketplace.eclipse.org/marketplace-client-intro?mpc_install=2566102 for details. This will simulate the Help--> install new software option in eclipse. 

After the installation, create/import project as Node.js Express project. 
Right click on the starting file (not the project directory) and select the 1st option (Node appication). Do not select the second option (Node.js application)
This will start the application on the default debug port of 5858.
After that the debugging, variable expressions are as in the case of Java (Not as user friendly since some of the options that we are used to in java debugging may not work here.). To set the breakpoint left click on the  margin (not right click on margin as I am used to in java eclipse debugging).
How to debug video is available at http://www.nodeclipse.org/usage
Good MongoDB material
=======================
https://www.tutorialspoint.com/mongodb/

Mongo DB
===============
Table in RDBMS ==> Collections in Mongo DB.
database ==> database
tuple/row ==> document (this is a json document)
Mongodb is called a document database. 
It is a no fixed schema (means that there are tables do not need specific columns)

Mongo DB Installation and commands
===============
Install mongodb
Add the bin to path
create a folder for data . Use md <folder> for this
start db by  mongod --dbpath <above_folder>

Now to connect use mongo command (This is similar to sqlplus)
show dbs   ---> Shows all databases
use <dbname> -- Goes to that database. It will also create that db.
to shutdown the db server gracefully,	
	use admin  --> So that you are in admin database
	db.shutdownServer()
	exit  --> After the db is shutdown, use this

To see collections (//r to tables in RDBMS), 
	use dbname
	show collections
To see logs
	show log

To create/drop dtabase/collections
	use <dbname> --> This will swich to the db. If not existimg, it will create also.
	dropDatabase() will drop the current database
	db.createCollection('express-templates') --> This creates the express-templates collections
	To display the database when using "show dbs", at least one collection should be created in that database.
	// to drop use the following
	var mydb = db.getCollection('express-templates');
	mydb.drop();  --> db.dbname.collection_name.drop() is an alternate syntax
	// The above will return true if existing

To view all documents(rows) in the collection, do the following
	var mydb = db.getCollection('express-templates');
	mydb.find();
	can also do the following in mongo shell
	db.express-templates.find();
	To beautify the above use db.express-templates.find().pretty();
To view specific documents(rows) in the collection, do the following
	var mydb = db.getCollection('express-templates');
	mydb.find({"runs":6,"batsman":"Sunil Gavaskar"});  -->  This will find  records that has Sunil gavaskar as the batsman and runs=6
Insert, Delete. Update
=====================
var mydb = db.getCollection('cricket');
mydb.insert({'batsman': 'Tendulkar', 'score':6});  ---> db.collection_name.insert({YOUR_JSON}). This will create the collection also if it not pre-existing.
mydb.remove({'score':6}); ---> equivalent syntax is db.collection_name.remove({YOUR_JSON}).
mydb.update({'score':6,'batsman':'Tendulkar'},  {$set:{'score':10}},   {upsert:true,multi:true})  ---> Updates the score to 10P.--> equivalent syntax is db.collection_name.update({YOUR_JSON}).
Update has multiple options. The general synats is 
	db.collection.update(
	   < >,
	   <update>,
	   {
	     upsert: <boolean>,
	     multi: <boolean>,
	     writeConcern: <document>,
	     collation: <document>
	   }
	)
	Read them at 
	https://docs.mongodb.com/manual/reference/method/db.collection.update/

	Details OF update options such as *$SET, $UNSET etc are available at 

	https://docs.mongodb.com/manual/reference/operator/update-field/


MongoDB- Node JS interaction
=============================
(a) by native mongodb library --> Suppossed to be more powerful. npm install mongodb
(b) by mongoose library --npm install mongoose
mongodb://localhost/cricket --> did not connect. Had to use mongodb://127.0.0.1/cricket
npm init is always needed first before doing npm install. Otherwise, the node_modules would not be created.

Hazelcast is the default caching mechanism with WSO2
======================================================

MongoDB namespace
======================
Search for https://docs.mongodb.com/manual/reference/glossary/ to understand what a namespace is

Db--> Collections --> Documents
=====================================

MongoDB query tutorials
==============================
https://docs.mongodb.com/manual/tutorial/query-documents/
What options can be used in find (query) are available at https://mongodb.github.io/node-mongodb-native/api-generated/collection.html#find
Native MongoDB Driver v/s Mongoose driver
===========================================
 MongoDB Driver is more powerful. 
 The advantage of Mongoose is that it is similar to an RDBMS driver. So programmers could be more familiar with it. It has SQL like syntax. Also, mongoose is better suited for fixed coulmns collections. Helps in validating the data. To do al these, we will need to write your own code in native mongod db. But it is provided out of the box in MongoDB.
 Mongoose allows you to define a schema (basically your collection structure ie; table definition).

 Mongoose & Mongoose API
 ==============
 Mongoose applies schemas. It is no longer free sructure. With Mongoose, it has structure and rules (ie; schema). Mongoose is similar to ORM (Object Relation Model) in Java.
 The API is available at http://mongoosejs.com/docs/api.html
 It is not well organized. Read it carefully along with sample programs to understand fully well.

GROUP BY SYNTAX in MONGODB
=============================
Find the group by syntax in mongodb at 
http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html



Validation on Insert
=========================
To understand how to do validation on insert, Refer the program mongooseaddrecordwithvalidation.js.
Pay attention to the syntax of the callback function validate and also to the syntax err.errors.runs.message

Adobe Connect - Moxtra selection
==================================

WYSWYG selection
==================
TinyMCE  --> Existing
tkWWW etc
Fond list of wyswyg editors at https://en.wikipedia.org/wiki/List_of_HTML_editors
https://textbox.io/  
Also explored webdav (It uses HTTP PUT)

ETL v/s ESB
==============
ETL ---> Talend, Pentaho. Talend also have esb capabilties.
ESB ------> WSO2. Apache synapse, Apache camel, Apache ServiceMix, MULE Soft.
Apache ServiceMix is based on Apache Camel.
WSO2's esb engine is Apache synapse.

Name of our project can not be the same as the modules that we are going to install
=====================================================================================
font-awesome
===================
 http://fontawesome.io/ has has got beautiful font and css
 Use https://www.tutorialspoint.com/web_icons/ for font-awesome tutorials

 
 XHR
 ===========
XHR is simple old  XMLHttpRequest on which ajax calls are based on.
XMLHttpRequest (XHR) is an API that can be used by JavaScript, JScript, VBScript, and other web browser scripting languages to transfer and manipulate XML data to and from a webserver using HTTP, establishing an independent connection channel between a webpage's Client-Side and Server-Side

Node JS with rest end points
================================
If we are just using Node JS for rest APIs, then instead of 
response.render("PageName", {json object}); 
do the following
response.json({json object})

Node JS Gaps as compared with the established Java/J2EE web based technolgies
==============================================================================
(a) Connection pooling
(b) How does I18n work ?
(c) Log levels as in log4j/commons logger. Chalk gives only colour coding to the extendt that I am aware of it. It does not provide file based loggers that we would need for debugging production issues. It does not provide log level based logging as far as I am aware of it.   ====> Update on 23rd Aug 2017. May be Morgan is the answer. Refer https://www.npmjs.com/package/morgan . It has got file writing, log file rotation. It also has something similar to log levels with more or less output logging based on what we have configured. But this seems to be limited to request logging.
Another request logger is express logger. https://gist.github.com/leommoore/7524073
(4) JDBC is DB independant in Java. In java, we need the same package in code irrespecive of the database that the code is connecting to. But here it seems that we need to import (require) a different module based on the database that we connect to. It is not abstracted and made DB independant the best of my knowledge.

pre method
==================
pre method on let us say save, will call the pre method and only then call the save method.
The syntax for pre method is something like
pre('originalMethodName', function(next) {
	// Based on logic call next() which will call the actual method.
}
This synatx helps a lot in validate methods.


The greatest purpose of package.json is to ensure that the copy of the dependancy libraries are not copied from github to the deployment (heroku) environment. The deployment environment like heroku already has copies of that. However the question that I have is, what happens in case of a version conflict ? is such a version conflict possible at all as the dependacies mentioned in the package.json also.

Unlike import in JAVA, the require in node js should be in the same order as they are called. 
===============================================================================================
Eg:-- If module a is used before module b, then require(module a) should appear earlier than require(module b)
Session, bodyparser, static, template engines(???) are all middlewares in node js concepts.
===============================================================================================

Difference between Module and package
==================================================================
https://docs.npmjs.com/how-npm-works/packages

Express-session options
==========================
 Refer https:www.npmjs.com/package/express-session-expire-timeout for various session option . The session timeout default seems to be infinity.
 cookie: { secure: true } also below would set secure flag on the cookie. But for this  to work, https is needed. 
 app.use(session({"secret":"secret", "resave":"true", "saveUninitialized":"true"})); //deprecated

 method-override NPM package
 ==============================
Lets you use HTTP verbs such as PUT or DELETE in places where the client doesn't support it.
https://www.npmjs.com/package/method-override
Express error handling 400 and 500 series errors and other errors
==================================================================
http://expressjs.com/en/guide/error-handling.html
All details are in that link. 
res.status(500).send(); ===> Sends 500 error

PRE & POST Methods
========================
Mongoose schema has pre and post methods that can be called before let us say, save method of a model.
The details are available in the mongoose API at 
http://mongoosejs.com/docs/api.html#schema_Schema
A typical use would be to hash a password before saving it. Code sample is available in the db.js of leave-the-marks-master project in the Day 5 code.



MongoLabs (MLabs), MongoImport and MongoExport
=========================================
MLabs URL to login ---> https://mlab.com/login/
username:-- sujithbabu
Password: Power@30
DB Name that is created : sujith
DB user name: sujithuser
DN Password: sujithpassword
	To connect using the mongo shell:
		mongo ds157500.mlab.com:57500/sujith -u sujithuser -p sujithpassword

	To connect using a driver via the standard MongoDB URI (what's this?):
		mongodb://sujithuser:sujithpassword@ds157500.mlab.com:57500/sujith

To import the collection named cricketScores from local database named cricket to the file 'cricketScores.json', use the following command (NOT in Mongo shell. This has to be done in regular command prompt)
mongoexport --db cricket --collection cricketScores --out cricketScores.json

Now you can import to the remote cloud database like the below (Again, NOT in Mongo shell. This has to be done in regular command prompt)

mongoimport -h ds157500.mlab.com:57500 -d sujith -c cricketScores -u sujithuser -p sujithpassword --file cricketScores.json
The above will create the collection cricketScores if it not already present in the database. If already present, that will be reused.

mongoexport, mongoimport command detailss are available at https://docs.mongodb.com/manual/reference/program/. Click on MongoDB Package Components link on the left panel.  
Details are also available on MLabs after login on the 'Tools' tab.

Apache Kafka v/s Rabbit MQ v/s Active MQ v/s Open JMS
=======================================================
We chose Rabbit MQ for our product (agConnect) since it has some indirect way of fully supporting secured multi-tenancy where tenant data is not mixed-up. They use vhosts (same as in apache web server) for this.

Web Socket is a specification in HTML 5. Socket.io is an implementation of it in Node Js. WS.io, engine.io are other implemenations of web socket html5 specification in node.js 
============================================================================

HttpServer core module API v/s Express third party API v/s Sockets.io API
============================================================================
It is either express or http server in node js generally. We use express because it is more powerful (similar to JSP in J2ee terms), whereas http server is similar to servlets and not so poweful. For this reason, in general, we use the third party express package and not the httpServer APIs that are core modules of node.js. But for sockets.io APIs, we need httpServer even when we use express.

Socket.io
===================
In web sockets, there is a server socket and a client socket. The connected method(event) is on the server socket side. But the disconnect and chat-message are on the client socket. Note that while connected and disconnected are standard API events, chat-message is our own custom event name and the name can be anything.
io.emit() in server code emits message to all the clients. socket.emit() emits message to only that socket.
scoekt.on is an event.
socket.emit is a method.


STATIC middleware details
===========================
// This folder is the one from the static files are served. 
// By default, the index.html is the index file
app.use(exp.static(__dirname+ "/public"));

By default the index.html is the index file. So / will match this index.html

My sample summer note (a WYWWYG editor) is at https://github.com/sujithbabu1971/ExpressJSSamples/tree/master/public (summernote.html)
Web Sockets good material
===============================
https://os.alfajango.com/websockets-slides/#/

connection and disconnect are the events in Socket.io
==========================================================

Sockets.io ---> How to create separate rooms for chats
==========================================================
Use Namespaces for the same.
Socket.IO allows you to “namespace” your sockets, which essentially means assigning different endpoints or paths.
Refer the API https://socket.io/docs/rooms-and-namespaces/ for that. It has join method. There does not seem to be any explicit leave method as disconnect event seems to be enough.

Events in node.js
=====================
Events is a core module.
The core API is https://nodejs.org/dist/latest-v6.x/docs/api/events.html
EventEmitter is the base module. All methods on this is available at https://nodejs.org/dist/latest-v6.x/docs/api/events.html
Obviously sockets.io extends from events module if we can compare this with JAVA.
Sample code is as below. 

		const EventEmitter = require('events');

		class MyEmitter extends EventEmitter {}

		const myEmitter = new MyEmitter();
		// on is the key word.
		myEmitter.on('event name', () => {
		  console.log('an event occurred!');
		});
		myEmitter.emit('event name');


		Asynchronous vs. Synchronous#
			The EventListener calls all listeners synchronously in the order in which they were registered. This is important to ensure the proper sequencing of events and to avoid race conditions or logic errors. When appropriate, listener functions can switch to an asynchronous mode of operation using the setImmediate() or process.nextTick() methods:

		const myEmitter = new MyEmitter();
		myEmitter.on('event', (a, b) => {
		  setImmediate(() => {
		    console.log('this happens asynchronously');
		  });
		});
		myEmitter.emit('event', 'a', 'b');
		
		Handling events only once#
		When a listener is registered using the eventEmitter.on() method, that listener will be invoked every time the named event is emitted.

		const myEmitter = new MyEmitter();
		let m = 0;
		myEmitter.on('event', () => {
		  console.log(++m);
		});
		myEmitter.emit('event');
		// Prints: 1
		myEmitter.emit('event');
		// Prints: 2
		Using the eventEmitter.once() method, it is possible to register a listener that is called at most once for a particular event. Once the event is emitted, the listener is unregistered and then called.

		const myEmitter = new MyEmitter();
		let m = 0;
		myEmitter.once('event', () => {
		  console.log(++m);
		});
		myEmitter.emit('event');
		// Prints: 1
		myEmitter.emit('event');
		// Ignored

WebRTC
==================
WebRTC ("Web Real-Time Communication") is a collection of communications protocols and application programming interfaces that enable real-time communication over peer-to-peer connections. This allows web browsers to not only request resources from backend servers, but also real-time information from browsers of other users.

This enables applications such as video conferencing, file transfer, chat, or desktop sharing without the need of either internal or external plugins.[1]


The idea in Sockets.io is to EMIT from client and server handling that with ON. During this ON processing, the server will EMIT and the client will have to handle with ON. You just need to understand this and get the programming cycle right. 


GRUNT, GULP Tools
==================
For GRUNT refer https://gruntjs.com/ This is the official material.
GULP is in memory while GRUNT creates temporary files. So obviously GULP is faster.
Also GULP has piping feature.
GULP is asynchronous in nature with node js synatx. GRUNT is more like a configuration language.
GULP is overtaking GRUNT, 
GULP has many plugins for reactjs, angular js etc https://gulpjs.com/plugins/


Install GRUN/GULP in dev dependancy mode
=======================================================================
npm install grunt --save-dev  --> For grunt command. Set path to the bin under <<>Installation_Directory>\node_modules\grunt\bin.
It is better to install all grunt and gulp related packages with global scope as they are just development dependancies.
This will install "devDependencies": {
    "grunt": "^1.0.1"
  }

Other synatx variations like does not install grunt/gulp as dep dependancy only.

Also install npm install grunt-contrib-cssmin --save-dev --> For minification of css script
Provide Gruntfile.js / gulpfile.js. (Case sensitive). Remeber it is Small GULP, Big GRUNT
=======================================================================


npm install grunt-contrib-uglify --save-dev  --> For minification of java script. This also does code mangling. (Same thing that we used in applet code long time back whereby variable names were mangled.). To avoid the mangling so that we can read the code better, use mangle:false. By default mangle is true in both GRUNT and GULP (I have verified this with hands-on exercise in both GRUNT and GULP).


Also install npm install grunt-contrib-watch --save-dev ---> This is to ensure minification after each edit without having to run the grunt minify task again.
combine in css-min and jscript files mean minifying first and then combining
GULP
============
https://gulpjs.com/ is the official material
npm install gulp --save-dev   ----> GULP
npm install gulp-cssnano --save-dev ----> GULP css minification
npm install gulp-concat --save-dev ----> GULP file joining (both css and java script)
npm install gulp-uglify --save-dev ----> GULP file joining (both css and java script)
Watch is also supported in GULP. But it does not need another installable unlike GRUNT.

In GULP, the task names can be anything unlike GRUNT where it was alwyas fixed. For an example, I tried to change the uglify name to uglifyWithAnotherSyntax in gGRUNT and it did not work.But in GULP this worked.
Here also, please mangle option is to be set to false to avoid variable renaming.
GULP syntax is similar to node js synatx.
GULP has many plugins for reactjs, angular js etc https://gulpjs.com/plugins/

Watch out for the version difference between the GULP global version that provides GULP command and the local GULP version that is instaled in the node_modules of the project 

Java_Code_Coverage_Tools
=========================
Cobertura

Browser can download only two files at a time
==============================================

GRUNT is more like a configuration language. But GULP is an asynchronous node js code.
========================================================================================
Linting is a generic term for finding out issues in code. Refer https://en.wikipedia.org/wiki/Lint_%28software%29 . But in java script terminology, it seems to mean verifying potential syntax error during build stage itself since otherwise an intrepreted language like java script will check synatx errors only at the runtime.

To update npm itelf
======================
npm update -g npm

Difference between Grunt-cli and grunt
=======================================
cli stands for command line. It seems to install the command, but for it to work correctly grunt also should be installed. This seems to be the difference. The details are available at https://gruntjs.com/getting-started. However, on first reading the difference is not very clear.
The above mechanism allows GRUNT version to be different for each project. Same is the case for GULP. It seems to insist on using the GRUNT in the local node_modules directory always and not the ones installed globally.

GULP runs tasks asynchronously. They run independantly. But if you want serial order, it is possible. Read https://github.com/gulpjs/gulp/blob/master/docs/API.md#async-task-support and https://stackoverflow.com/questions/29694425/what-does-gulp-done-method-do

The code will be something like
	var gulp = require('gulp');
	// Takes in a callback so the engine knows when it'll be done
	// This callback is passed in by Gulp - they are not arguments / parameters
	// for your task.
	gulp.task('one', function(cb) {
	    // Do stuff -- async or otherwise
	    // If err is not null and not undefined, then this task will stop, 
	    // and note that it failed
	    cb(err); 
	});
	// Identifies a dependent task must be complete before this one begins
	gulp.task('two', ['one'], function() {
	    // Task 'one' is done now, this will now run...
	});
	gulp.task('default', ['one', 'two']);


FS Module in Node JS is similar to IO package in JAVA
=======================================================
FS Module in Node JS is similar to IO package in JAVA

WATCH in both GRUNT and GULP takes effect only after changing contents. It does not run the 1st time. This is the default behaviour at least.
================================================================================================================================================
May be there are options to change them.
=========================================================

MOCHA, CHAI and other Testing concepts
=================================================

Unlike JUnits, the test runners and testing frameworks seem to come from different players here.
Note that Mocha and Chai are to be installed globally. They need not be mentioned in the package-json as dependancies or dev-dependancies since they are of test scope (like test scope for JUnit in maven).
npm install -g mocha  --> This will install the mocha command
npm install -g chai  
npm install -g chai-http  

Test Runners: KARMA, PROTRACTOR (Not really needed for serer side like Node.JS. Needed for client side like Angular JS or React JS).
Testing Frameworks: MOCHA, QUNINT(Older one, not that powefrul), JASMIN.
MOCHA is the best and fastest.
Assertion engines(Test case Writing tools/styles): SHOULD, Expect.JS, ASSERTION style (Similar to JUnit style). CHAI can mix these styles. Install Chai globally.

	In Mocha(it is a framework), we need to use an assertion engine library like CHAI that allows us to specify an assertion engine like SHould/Assert/Expect. But Jasmine(a competeitor framework to Mocha), this assertion is not needed. However Mocha seems to be more popular


Assertion engines (Test case writing styles)

	var expect = require('chai').expect;
	var assert = require('chai').assert;
	// Note that here it is should() and not just should.
	// Whereas for expect and assert styles, it is just assert and expect.
	var should = require('chai').should();
CHAI is the style and MOCHA is the testing framework


Chai http://chaijs.com/
Mocha https://mochajs.org/


Note that MOCHA seems to be like JUNIt in the sense that it is better to use it for business 
=============================================================================================
tier that does not have any session/request/response like objects.
===================================================================
In traditional Java/J2EE,we have fixed this issue by using cacus (in Struts) or Mock objects that simulates request/response/web servers. Here the chai-http seems to be for this purpose.


CHAI-HTTP
=================
https://github.com/chaijs/chai-http
It seems that chai-http needs to be installed locally as a dev-dependancy. For me, installing MOCHA and CHAI as global dependacies and not mentioning them in package-json worked. However the same for chai-http resulted in module not found for 'chai-http'. In short, I had to mention only chai-http as a dev dependancy and install them locally in the node-modules for test cases to work.
However, at the example in https://scotch.io/tutorials/test-a-node-restful-api-with-mocha-and-chai, they have mentioned all 3 (Mocha, Chai and Chai-http) as dev dependancies. 
As per the documentation available at https://github.com/chaijs/chai-http, it seems that there are no methods to deep dive into a response and compare the contents.
But there are methods like request should have a parameter named 'XYZ', response should be status '200', request/response should have header name 'OOO', response should have html content etc.
	To deep dive into the a response and compare the contents, use some code like this.
	Here the content is proper if it has the text "Input Your Chat Name". So, I have written the code for that and it worked. Refer the test code in my github at https://github.com/sujithbabu1971/WebSockets/blob/master/test/requestTest.js 

		    var resString = JSON.stringify(res);
		    // If the response is correct, the text would be contained in the output html.
		    var properOutput = resString.includes("Input Your Chat Name");
		    console.log(properOutput);
		    assert.equal(properOutput,true);

Caveat from https://github.com/chaijs/chai-http for asynchronous behaviour of chai-http.
==========================================================================================

Because the end function is passed a callback, assertions are run asynchronously. Therefore, a mechanism must be used to notify the testing framework that the callback has completed. Otherwise, the test will pass before the assertions are checked.

For example, in the Mocha test framework, this is accomplished using the done callback, which signal that the callback has completed, and the assertions can be verified:

Where are the test cases
===========================
By default all js files under test folder of project are considered as test files. When you type mocha at command prompt, they will be run.
You can also do <mocha filename.js> that runs test cases in the filename.js 

What is Deep-Eql?
=======================
https://github.com/chaijs/deep-eql
Deep Eql is a module which you can use to determine if two objects are "deeply" equal - that is, rather than having referential equality (a === b), this module checks an object's keys recursively, until it finds primitives to check for referential equality. 


npm --version, mocha --version, gulp --vresion, grunt --version will give you the version numbers
================================================================

arguments.length  in java script functions
=============================================
functions()
{
	arguments.length ---> This will give you the length of the arguments passed within functions.
	Magic of java script !!!! 
}

In mocha , 'describe' is the syntax for test suite and 'it' is syntaxt for test case.
========================================================================================
Note that decsribe and it are not java script methods, they are provided by mocha framework.
Sample code:
	describe('tests', function(){
	// it is syntaxt for test case.
	it('some tests', function(){
		
		var a='a';
		// Will pass
		expect(a).to.equal('a');
		// Will pass
		assert.equal(a,'a');
		// Will pass
		a.should.equal('a');
		// Will  fail
		expect(a).to.equal('b');
		
		
		
	});
	
	});

We can have multiple test suites (multiple describes) within a test file. We can have multiple test cases within a test suite (multiple 'it' within a describe). This is excactly similar to Java JUnits. This feature allows us to have a separate test suites for test functionalities. Eg:-- One test suite (describe) for a customer functionality, another one for admin functionality etc.


BDD and TDD
================
Behaviour Driven Development and Test Driven Development

Refer https://codeutopia.net/blog/2015/03/01/unit-testing-tdd-and-bdd/ for understanding the differences. There is a good example. Also read https://en.wikipedia.org/wiki/Behavior-driven_development
BDD in java --> Cucumber. Selenium is automated request side testing.
BDD using SELENIUM allows feature file that buiness analysts can use easily to decsribe testing.
Since I have JUnit exposure, may be I can use Assert style in CHAI. But Assert style is TDD. But it time to advance to BDD. So better learn SHOULD/EXPECT which are BDD styles.
assert is the only one that is not chainable while should/expect are chainable. (ie;output from one becomes the input to the next).
Example for chaineable: expect([1, 2, 3]).to.have.lengthOf.below(4)
Greater than and less than is handled by above and below in should/expect styles.

Refer http://chaijs.com/api/bdd/ for all the available syntax on BDD.Refer http://chaijs.com/api/assert/ for all the available syntax on TDD.

==============================================================================================================================
The above style seems to be better as we can express test statements in more english like language.
For an example, in BDD the following works
expect([1, 2, 3]).to.have.lengthOf.below(4);
But in TDD (Assert), we need to achieve this in the following way
	var length = [1, 2, 3].length;
	Assert.isTrue(length<4);
So some more code is needed in TDD here and is not all that behaviour driven.

TEAR DOWN , setUp equivalents of JUNIT in MOCHA
============================================
For a one time set up that runs once before any test is run, use before.
For a one time tear down that runs once after all tests have run, use after.
To run before each test use beforeEach.
To run after each test use afterEach.

There is no testScope dependancy in Node JS. It is only dev-dependancy in Node JS.
=================================================================================
For an example, Mocha, chai and Chai-http are mentioned as devDependencies in the example at https://scotch.io/tutorials/test-a-node-restful-api-with-mocha-and-chai . I have also done the same in my sample codes.



JASMINE
================
https://jasmine.github.io/2.1/introduction.html
Jasmine is a competitor to MOCHA.
It seems to include only BDD style unlike MOCHA that has support for both BDD and TDD.
It seems that only Jasmine needs to be installed here unlike MOCHA where we need to install MOCHA and then install CHAI as the assertion engine. The assertion engine is possibly included in Jasmine itself.
https://jasmine.github.io/2.1/introduction.html has all initial details. 

An observation on GIT Hub Commit and Push
======================================================
Assume a scenario like this:
	You commit and before pushing make some more changes and save.
	Now at the push only the committed version gets pushed to GIT HUB.

HAPI
=========
Hapi is an equivalent to Express. Unlike express, you need not install NPMs for session, post separately. But template engine like handlebars need to be installed separaley as in the case of express.
If handlebar is used with express, then install express-handlebar. But if using with HAPi, just do npm install handlebar (generic handlebar installation)
The equivalent to public in ejs is insert in HAPI

npm install hapi
npm install handlebar
npm install inert (equivalent to public )
npm install vision (needed for template engines)

MYSQL
=========
 npm install mysql

 Handlebars {{ and {{{ 
 =========================
 Handlebars HTML-escapes values returned by a {{expression}}. If you don't want Handlebars to escape a value, use the "triple-stash", {{{.
 http://handlebarsjs.com/#html-escaping

 MYSQL creation in amazon web services
 =======================================
 Once you create the mysql db instance in amazon web services by following the regular steps, do the following also.
 Click on Instance Actions --- > see details --> Click on Security Group default ---> Click on Inbound tab --> edit --> Make Source as 'Anywhere'
 This would allow you to connect to the database from anywhere in the internet.

 Dowload the mysql workbench (This is the mysql client). This is similar to the sql developer.
 
 METEOR
 ==========
Meteor is an all inclusive framework that is dependant on Node JS.
Obviously node JS needs to be installed before installing METEOR.
In MEAN, we have different components such as Mongodb as the database, express JS as the server side template engine and framework, angular JS in the front end, Node JS as the backend programming language. But in METOR it is all integrated. It apparenty has even buid tool, unit tests included. The philosophy is take everything. There is no plug and play. MongodDB is also included within. MongDB can be accessed within the front-end unlike the regular MEAN stack. 
Think agCarbon v/s agLite

https://wiki.dandascalescu.com/essays/why_meteor
There is no NPM installation here.
The logic is something like

	if(Metoer.isClient) {
		// Write all the client code
	}

	if(Metoer.isServer) {
		// Write all the server code
	}

So, in a single file you have all the code.
It uses a trimmed down version of handleBars called spaceBars. (No separate installable needed).

Server Push (websockets) is installed by default in Meteor. The moment you change somecode and save it, it will be reflected in all the connected browsers. This is enabled even if you do not write code for that.
Thus it is real time and two-way. 
The learning curve seems to be small.
There seems to be a lot of community support.
Disadvantages of METEOR:
(a) No plug and play allowed. You can not plug your component.
(b) Obviously against open source priciples of sharing. (Think agCarbon v/s agLite)
(c) Since it is duplex, a live connection is held between browser(client) and server. This connection is kept in memory for all connected memories. In usual http connection, it is single sided and as soon as a request is served, the request thread goes back to the request thread pool and memory is not used. But here it is not like that and therfore resource intensive.

If you are using angular JS for everything , then may be you do not need templating engine. However this may not be the case in a realistic project , especially the one that has a lot of security requirements. You will end up using a lot of templating code since you will need a lot more data from the server.

There seems to be a METEOR cloud also.
The file name of html and css are the same (except for the file extension). Thus html would be able to locate the css file without having to look for css using the head and link tags.
The template code is in the same file in Metor.
In meteor, you can use the Mongo API on the client. You've never seen this before. Up until this point in history, database APIs only worked on the server. But in Meteor, there isn't a server API and a client API. There's just the Meteor platform API. And it works everywhere.

Meteor supports three view engines: React, Angular, and its own Blaze.

MongoDB is by its nature more resistant against database injections than SQL because it doesn't parse inputs. But MongoDB can also be hacked.
========================================================================================================================================================
(Source: https://wiki.dandascalescu.com/essays/why_meteor)

 Node is notoriously scalable
 ===========================
 - 1 million concurrent connections laughs at C10K and in raw terms, Node is faster than PHP. PayPal rewrote with Node.js their account overview page, one of the most trafficked apps on the website and formerly written in Java. (Source: https://wiki.dandascalescu.com/essays/why_meteor)

 Model–view–viewmodel (MVVM) is a software architectural pattern.
 ==================================================================

 Metor gets deployed to meteor.com
 ==================================
 May be there are ways of changing that. (Otherwise, on-premise installation may not be possible). When the local app is deployed to meotor, only the app gets installed and not the data. This is the intended and correct behaviour also.

If you have to develop only REST APIs, do not use METEOR. (Source: https://wiki.dandascalescu.com/essays/why_meteor)
================================================================
When all you want is to build a web-service / REST API, without a client. In that case, a Sails.js or Hapi might be sufficient, while Meteor could be overkill. In my(Sujith's) opinion, plain express with EJS will be enough here. Even HAPI (replacement for express) might not be required.

jsonwebtoken
================
https://www.npmjs.com/package/jsonwebtoken
Its use is similar to the CSRF (Cross site request forgery) guard servlet that we had used. (https://www.owasp.org/index.php/Top_10_2013-A8-Cross-Site_Request_Forgery_(CSRF))  

Sample code
===============
	/**
 * http://usejsdoc.org/
 */
// Refer https://www.npmjs.com/package/jsonwebtoken

var jwt = require('jsonwebtoken');
var secretKey='secret';
var token = jwt.sign({
	// Note this can be an user object from the datbase.
	// Something like userId:1,userName:sujith,password:vvv
  data: 'foobar'
	  // Expires In is in seconds
}, secretKey, { expiresIn: 30 * 60 });

console.log(token);
// Now pass it to the page using params. Include that in the page as a hidden param
// It can be set as a header also
// Now in the app.use, do the following
// We will need to add a new middleware. This would be similar to servlet filters

// The code would be something like
 apiRoutes.use(req,res, next){
	var token = //get tken from header or body.
	if(token)
	{
		jwt.verify(token, secretKey, function(err, decoded) {
			if(err){
				// Log the error,
				// return error page
				
			}else{
				// everything is fine.
				// call next(). That will forward to the intended page;
				// decoded will have the value data: 'foobar' or whatever is encrypted earlier
				next();
			}
			   
			});
	}
	else{
		// Log the error,
		// return error page
	}
}


var decoded = jwt.verify(token, secretKey);
console.log(decoded);

Load balancing is done without any extra load balancer (apache web server/ hardware load balacer etc) in Node JS
============================================================================================================================
For that, some code like this will help. Refer https://nodejs.org/dist/latest-v6.x/docs/api/cluster.html 

	const cluster = require('cluster');
	const numCPUs = require('os').cpus().length;

	if (cluster.isMaster) {
	  console.log(`Master ${process.pid} is running`);

	  // Fork workers.
	  for (let i = 0; i < numCPUs; i++) {
	    cluster.fork();
	  }

But we will need to have sticky session or session failover.

Sticky Session --> https://stackoverflow.com/questions/23991413/how-to-use-sticky-session-with-cluster-in-express-node-js  

	Some code like this will work.

	var http = require('http');
	var cluster = require('cluster'); // Only required if you want the worker id
	var sticky = require('sticky-session');
	var express = require('express');
	var app = express();

	app.get('/', function (req, res) {
	    console.log('worker: ' + cluster.worker.id);
	    res.send('Hello World!');
	});

	var server = http.createServer(app);
	sticky.listen(server,3000);

Session failover using DB (Similar to what we do in weblogic where we store session data in database) ---> https://stackoverflow.com/questions/17626279/nodejs-clustering-and-expressjs-sessions  https://stackoverflow.com/questions/17600272/session-undefined-using-connect-redis-expressjs-node/17606825#17606825

process.argv
=================
This is similar to the args in main. But by default agv[0] is node.exe and agv[1] is the filename.js
The actual arguments start from argv[2].

child_process
================
Read https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_spawning_bat_and_cmd_files_on_windows

The following spawns server.js


	var spawn = require('child_process').spawn;
	var child = spawn ('node ./server.js);

	var express = require('express');
	var app = express();

	app.get("/", function (req, res) {
		res.end("Hello World");

	}

Master process and child process interaction
================================================
You can intechange data between master process and its child process using the on event handler and using send method
The events are  'close', 'disconnect', 'error', 'exit' and  'message'.
My sample program is available at https://github.com/sujithbabu1971/mongodbprograms/
(Refer mainProcessWithSubInteraction.js and subProcess.js in the above link).
Refer the document at 
https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html
It says the below.
	When an IPC channel has been established between the parent and child ( i.e. when using child_process.fork()), the child.send() method can be used to send messages to the child process. When the child process is a Node.js instance, these messages can be received via the process.on('message') event.

	For example, in the parent script:

	const cp = require('child_process');
	const n = cp.fork(`${__dirname}/sub.js`);

	n.on('message', (m) => {
	  console.log('PARENT got message:', m);
	});

	n.send({ hello: 'world' });
	And then the child script, 'sub.js' might look like this:

	process.on('message', (m) => {
	  console.log('CHILD got message:', m);
	});

	process.send({ foo: 'bar' });


OAuth 
======
OAuth is a big specification.
A good OAuth tutorial can be found at http://tutorials.jenkov.com/oauth2/index.html
For facebook it is https://developers.facebook.com/docs/facebook-login/access-tokens

In terms of code, it would be something like the below for an overtly simple scenario.
Step 1:--
	Get the user access token by making a call like the below
	GET /oauth/access_token
    ?client_id={app-id}
    &client_secret={app-secret}
    &grant_type=client_credentials
Step 2:--
	Call the app server URL with the user access tokem from above.

The above is a simple scenario. It would get complex, when we have page access tokens, page permissions etc. But that would be a realistic scenario. For details, google OAUTh 2.0 sequence diagrams and the link https://developers.facebook.com/docs/facebook-login/access-tokens
F


connect-flash module
======================
https://www.npmjs.com/package/connect-flash
The flash is a special area of the session used for storing messages. Messages are written to the flash and cleared after being displayed to the user. The flash is typically used in combination with redirects, ensuring that the message is available to the next page that is to be rendered.

This middleware was extracted from Express 2.x, after Express 3.x removed direct support for the flash. connect-flash brings this functionality back to Express 3.x, as well as any other middleware-compatible framework or application. +1 for radical reusability.


var flash = require('connect-flash');
var app = express();
 
app.configure(function() {
  app.use(express.cookieParser('keyboard cat'));
  app.use(express.session({ cookie: { maxAge: 60000 }}));
  app.use(flash());
});
With the flash middleware in place, all requests will have a req.flash() function that can be used for flash messages.

app.get('/flash', function(req, res){
  // Set a flash message by passing the key, followed by the value, to req.flash(). 
  req.flash('info', 'Flash is back!')
  res.redirect('/');
});
 
app.get('/', function(req, res){
  // Get an array of flash messages by passing the key to req.flash() 
  res.render('index', { messages: req.flash('info') });
});
PASSPORT (Similar to OAUTH concept)
=======================================
Module 7. Actual class under 'Course Content' tab. Go through the 100th and 144th minute. This has all the details on passport.

PASSPORT is very important authentication and authorization principle in Node JS
https://www.npmjs.com/package/passport
http://passportjs.org/
First select your login strategy (local strategy, facebook strategy etc). There are around 300 strategies. Refer the above links for details and tutorials. For an example the tutorial for local strategy in express 4 is available at http://mherman.org/blog/2015/01/31/local-authentication-with-passport-and-express-4/#.WaKI5igjHIU
Local strategy is like the below:
	passport.use(new LocalStrategy(
	  function(username, password, done) {
	    User.findOne({ username: username }, function (err, user) {
	      if (err) { return done(err); }
	      if (!user) { return done(null, false); }
	      if (!user.verifyPassword(password)) { return done(null, false); }
	      return done(null, user);
	    });
	  }
	));
Then provide code for serializing/ deserializing users

	passport.serializeUser(function(user, done) {
	  done(null, user.id);
	});
	 
	passport.deserializeUser(function(id, done) {
	  User.findById(id, function (err, user) {
	    done(err, user);
	  });
	});
Initialize the middleware
	Middleware
	To use Passport in an Express or Connect-based application, configure it with the required passport.initialize() middleware. If your application uses persistent login sessions (recommended, but not required), passport.session() middleware must also be used.

	var app = express();
	app.use(require('serve-static')(__dirname + '/../../public'));
	app.use(require('cookie-parser')());
	app.use(require('body-parser').urlencoded({ extended: true }));
	app.use(require('express-session')({ secret: 'keyboard cat', resave: true, saveUninitialized: true }));
	app.use(passport.initialize());
	app.use(passport.session());
Now Authenticate Requests
	Passport provides an authenticate() function, which is used as route middleware to authenticate requests.

	app.post('/login', 
	  passport.authenticate('local', { failureRedirect: '/login' }),
	  function(req, res) {
	    res.redirect('/');
	  });

Model–view–viewmodel (MVVM) is a software architectural pattern.
=================================================================
https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel

bower
===========
npm is the package manager for the server side.
The one for the client side is bower

https://bower.io/
First install bower through npm command globally
For that use "npm install -g bower"

"bower install <package>" will create a folder <bower_components\package at the current folder and put all the client side files (js etc) in that folder
For an example "bower install angular" will create a folder <bower_components\angular at the current folder and put all the client side files related to angularjs in that folder.
Now in your client html page, you can do 
	<script src="bower_components/angular/angular.min/js"> rather than giving <script src="http://XXX/YYY/WHAT_EVER/angular.min/js">
Infact "npm install angular" would also install angular similar to "bower install angular". But they will all be installed under node_modules as is usual with npm command. You need to copy the required js files to a client folder in your web application. This is avoided using the bower command/components. 

angular.module('main_module', ['dependancy_module_1','dependancy_module_2']);
==============================================================================

Revise spring singleton instance, multiple instance , ways of injecting them, ways of injecting singleton to multiple, multiple to singleton etc
============================================================================================================================================================

JavaScript encapsulation available in Day 8 of actual class between 66th and 67th minute


JavaScript Array splice() Method
===============================
❮ JavaScript Array Reference

Example
Add items to the array:

var fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.splice(2, 0, "Lemon", "Kiwi");
The result of fruits will be:

Banana,Orange,Lemon,Kiwi,Apple,Mango
Try it Yourself »
More "Try it Yourself" examples below.


Parameter Values
Parameter	Description
index	Required. An integer that specifies at what position to add/remove items, Use negative values to specify the position from the end of the array
howmany	Optional. The number of items to be removed. If set to 0, no items will be removed
item1, ..., itemX	Optional. The new item(s) to be added to the array

Every object is node js has event handling capabilities (In java, it is only for those objects implementing EventListener interface)
===============================================================================================================================================================

LAMP v/s MEAN
================
Linux, Apache, MySQL and PHP v/s MongoDB, Express JS, Angular JS and Node JS
Iconic Framework
=====================
https://ionicframework.com/ 
Ionic is the only mobile app stack that enables web developers apps for all major app stores and the mobile web with a single code base.

You write code in HTML5 and Java script. You buid using Cordova / Phonegap. It will work for IoS, Android, Windows and Balckberry phones.
IoS
=====
IoS applications can be developed using SWIFT also apart from by the usage of Objective C.

MDN
=============
Mozilla Development Network

OAUTH
======
The authorization grant is a credential that represents the resource owner's authorization that can
be used to access a protected resource. This credential is used by the client to obtain an access
token, and this access token is eventually sent along with the request to access a protected
resource. OAuth 2.0 defines four grant types:

1. Authorization code
2. Implicit
3. Resource owner password credentials
4. Client credentials

For each, it behaves differently. But with authorization code, the general flow would be like the following: a user access http://flicer.com/someData. The client (here flicker.com) sends a clientId and redirection url (http://flicer.com/A) to facebook (the autentication server). Then facebook responds with an authorisation code. The authorization code is attached to the redirection URL (http://flicer.com/A?auth_code=xyx). Now flicker.com requests facebook for access token. For this, flikcer.com would conatct www.facebook.com/login and would pass the redirection URL (http://flicer.com/A?auth_code=xyx) as a param. Facebook.com now logins the user and also matches that the redirection URL and the auth code in http://flicer.com/A?auth_code=xyx is the same as that it received in the 1st step. If okay then facebook sends back the access code and refresh access code optionally (for offline) .  Now the client sends the actual request to http://flicer.com/someData by adding the access/refresh access token as a header to the request. The client gets the actual data and shows that to the user.

AUTHORIZATION CODE and ACCESS/REFRESH ACCESS TOKEN are the main terms here.

Look at https://www.ibm.com/developerworks/security/library/se-oauthjavapt3/se-oauthjavapt3-pdf.pdf for more details


(1) Heap memory is used by all the parts of the application whereas stack memory is used only by one thread of execution.
(2) Whenever an object is created, it’s always stored in the Heap space and stack memory contains the reference to it. Stack memory only contains local primitive variables and reference variables to objects in heap space.
(3) Objects stored in the heap are globally accessible whereas stack memory can’t be accessed by other threads.
(4) Memory management in stack is done in LIFO manner whereas it’s more complex in Heap memory because it’s used globally. Heap memory is divided into Young-Generation, Old-Generation etc, more details at Java Garbage Collection.
(5) Stack memory is short-lived whereas heap memory lives from the start till the end of application execution.
(6) We can use -Xms and -Xmx JVM option to define the startup size and maximum size of heap memory. We can use -Xss to define the stack memory size.
(7) When stack memory is full, Java runtime throws java.lang.StackOverFlowError whereas if heap memory is full, it throws java.lang.OutOfMemoryError: Java Heap Space error.
(8) Stack memory size is very less when compared to Heap memory. Because of simplicity in memory allocation (LIFO), stack memory is very fast when compared to heap memory.


